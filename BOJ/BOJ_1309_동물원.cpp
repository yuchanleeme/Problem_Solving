#include <iostream>
using namespace std;
//https://www.acmicpc.net/problem/

/*
<동물원>
주요: DP를 활용하자.
1. 2 * N 배열에 사자를 채우는 경우의 수를 dp[N] 이라고 하자.
2. 우선 2 * 1 칸에는 3가지 모양의 사자를 배치 할 수 있다.
  (1) 왼쪽만 (2) 오른쪽만 (3) 배치하지 않는다.
3. 2*N 배열 기준으로 보면 2*(N-1) 배열에서 2*1칸 추가를 하는 것이다.
4. 그렇기 때문에 원래대로라면 dp[N] = 3 * dp[N-1] 이어야만 한다.
  => 4-1) 하지만 2*(N-1) 칸에 한 칸이라도 배치가 되어있다면 2*N 칸에는 인접하지 않게 배치되는 2가지 경우만 배치 할 수 있다.
  => 4-2) 또한 2*(N-1) 칸에 한 칸도 배치되지 않는 경우라면 3가지 경우 모두 배치할 수 있다.
  => 이 경우 결국 dp[N-2]의 경우의 수와 같게 된다.
5. 4번을 종합하면 dp[N] = 2 * dp[N-1] + dp[N-2] 라는 점화식 도출이 가능하다.
  (dp[N-1]개는 모두 최소 2가지 경우씩 있고 그 중 3개짜리가 되는 dp[N-2]개 추가 한다는 뜻)

*/

int main() {

  int N;
  int dp[100001] = {1, 3,};

  cin >> N;

  for (int i = 2; i <= N; i++) {
    dp[i] = (2 * dp[i-1] + dp[i-2]) % 9901;
  }

  cout << dp[N];

  return 0;
}
